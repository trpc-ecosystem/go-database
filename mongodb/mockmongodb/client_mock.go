// Code generated by MockGen. DO NOT EDIT.
// Source: client.go

// Package mockmongodb is a generated GoMock package.
package mockmongodb

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	bson "go.mongodb.org/mongo-driver/bson"
	mongo "go.mongodb.org/mongo-driver/mongo"
	options "go.mongodb.org/mongo-driver/mongo/options"
	mongodb "trpc.group/trpc-go/trpc-database/mongodb"
)

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *MockClient) Aggregate(ctx context.Context, database, coll string, pipeline interface{}, opts ...*options.AggregateOptions) (*mongo.Cursor, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, pipeline}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Aggregate", varargs...)
	ret0, _ := ret[0].(*mongo.Cursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockClientMockRecorder) Aggregate(ctx, database, coll, pipeline interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, pipeline}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockClient)(nil).Aggregate), varargs...)
}

// BulkWrite mocks base method.
func (m *MockClient) BulkWrite(ctx context.Context, database, coll string, models []mongo.WriteModel, opts ...*options.BulkWriteOptions) (*mongo.BulkWriteResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, models}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BulkWrite", varargs...)
	ret0, _ := ret[0].(*mongo.BulkWriteResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BulkWrite indicates an expected call of BulkWrite.
func (mr *MockClientMockRecorder) BulkWrite(ctx, database, coll, models interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, models}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkWrite", reflect.TypeOf((*MockClient)(nil).BulkWrite), varargs...)
}

// Collection mocks base method.
func (m *MockClient) Collection(ctx context.Context, database, collection string) (*mongo.Collection, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Collection", ctx, database, collection)
	ret0, _ := ret[0].(*mongo.Collection)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Collection indicates an expected call of Collection.
func (mr *MockClientMockRecorder) Collection(ctx, database, collection interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Collection", reflect.TypeOf((*MockClient)(nil).Collection), ctx, database, collection)
}

// CountDocuments mocks base method.
func (m *MockClient) CountDocuments(ctx context.Context, database, coll string, filter interface{}, opts ...*options.CountOptions) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountDocuments", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountDocuments indicates an expected call of CountDocuments.
func (mr *MockClientMockRecorder) CountDocuments(ctx, database, coll, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountDocuments", reflect.TypeOf((*MockClient)(nil).CountDocuments), varargs...)
}

// Database mocks base method.
func (m *MockClient) Database(ctx context.Context, database string) (*mongo.Database, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Database", ctx, database)
	ret0, _ := ret[0].(*mongo.Database)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Database indicates an expected call of Database.
func (mr *MockClientMockRecorder) Database(ctx, database interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Database", reflect.TypeOf((*MockClient)(nil).Database), ctx, database)
}

// DeleteMany mocks base method.
func (m *MockClient) DeleteMany(ctx context.Context, database, coll string, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteMany", varargs...)
	ret0, _ := ret[0].(*mongo.DeleteResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteMany indicates an expected call of DeleteMany.
func (mr *MockClientMockRecorder) DeleteMany(ctx, database, coll, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMany", reflect.TypeOf((*MockClient)(nil).DeleteMany), varargs...)
}

// DeleteOne mocks base method.
func (m *MockClient) DeleteOne(ctx context.Context, database, coll string, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteOne", varargs...)
	ret0, _ := ret[0].(*mongo.DeleteResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteOne indicates an expected call of DeleteOne.
func (mr *MockClientMockRecorder) DeleteOne(ctx, database, coll, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockClient)(nil).DeleteOne), varargs...)
}

// Disconnect mocks base method.
func (m *MockClient) Disconnect(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Disconnect", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Disconnect indicates an expected call of Disconnect.
func (mr *MockClientMockRecorder) Disconnect(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Disconnect", reflect.TypeOf((*MockClient)(nil).Disconnect), ctx)
}

// Distinct mocks base method.
func (m *MockClient) Distinct(ctx context.Context, database, coll, fieldName string, filter interface{}, opts ...*options.DistinctOptions) ([]interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, fieldName, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Distinct", varargs...)
	ret0, _ := ret[0].([]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Distinct indicates an expected call of Distinct.
func (mr *MockClientMockRecorder) Distinct(ctx, database, coll, fieldName, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, fieldName, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Distinct", reflect.TypeOf((*MockClient)(nil).Distinct), varargs...)
}

// Do mocks base method.
func (m *MockClient) Do(ctx context.Context, cmd, db, coll string, args map[string]interface{}) (interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Do", ctx, cmd, db, coll, args)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Do indicates an expected call of Do.
func (mr *MockClientMockRecorder) Do(ctx, cmd, db, coll, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockClient)(nil).Do), ctx, cmd, db, coll, args)
}

// EstimatedDocumentCount mocks base method.
func (m *MockClient) EstimatedDocumentCount(ctx context.Context, database, coll string, opts ...*options.EstimatedDocumentCountOptions) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EstimatedDocumentCount", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EstimatedDocumentCount indicates an expected call of EstimatedDocumentCount.
func (mr *MockClientMockRecorder) EstimatedDocumentCount(ctx, database, coll interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EstimatedDocumentCount", reflect.TypeOf((*MockClient)(nil).EstimatedDocumentCount), varargs...)
}

// Find mocks base method.
func (m *MockClient) Find(ctx context.Context, database, coll string, filter interface{}, opts ...*options.FindOptions) (*mongo.Cursor, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Find", varargs...)
	ret0, _ := ret[0].(*mongo.Cursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Find indicates an expected call of Find.
func (mr *MockClientMockRecorder) Find(ctx, database, coll, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockClient)(nil).Find), varargs...)
}

// FindOne mocks base method.
func (m *MockClient) FindOne(ctx context.Context, database, coll string, filter interface{}, opts ...*options.FindOneOptions) *mongo.SingleResult {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindOne", varargs...)
	ret0, _ := ret[0].(*mongo.SingleResult)
	return ret0
}

// FindOne indicates an expected call of FindOne.
func (mr *MockClientMockRecorder) FindOne(ctx, database, coll, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockClient)(nil).FindOne), varargs...)
}

// FindOneAndDelete mocks base method.
func (m *MockClient) FindOneAndDelete(ctx context.Context, database, coll string, filter interface{}, opts ...*options.FindOneAndDeleteOptions) *mongo.SingleResult {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindOneAndDelete", varargs...)
	ret0, _ := ret[0].(*mongo.SingleResult)
	return ret0
}

// FindOneAndDelete indicates an expected call of FindOneAndDelete.
func (mr *MockClientMockRecorder) FindOneAndDelete(ctx, database, coll, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOneAndDelete", reflect.TypeOf((*MockClient)(nil).FindOneAndDelete), varargs...)
}

// FindOneAndReplace mocks base method.
func (m *MockClient) FindOneAndReplace(ctx context.Context, database, coll string, filter, replacement interface{}, opts ...*options.FindOneAndReplaceOptions) *mongo.SingleResult {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter, replacement}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindOneAndReplace", varargs...)
	ret0, _ := ret[0].(*mongo.SingleResult)
	return ret0
}

// FindOneAndReplace indicates an expected call of FindOneAndReplace.
func (mr *MockClientMockRecorder) FindOneAndReplace(ctx, database, coll, filter, replacement interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter, replacement}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOneAndReplace", reflect.TypeOf((*MockClient)(nil).FindOneAndReplace), varargs...)
}

// FindOneAndUpdate mocks base method.
func (m *MockClient) FindOneAndUpdate(ctx context.Context, database, coll string, filter, update interface{}, opts ...*options.FindOneAndUpdateOptions) *mongo.SingleResult {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter, update}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindOneAndUpdate", varargs...)
	ret0, _ := ret[0].(*mongo.SingleResult)
	return ret0
}

// FindOneAndUpdate indicates an expected call of FindOneAndUpdate.
func (mr *MockClientMockRecorder) FindOneAndUpdate(ctx, database, coll, filter, update interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter, update}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOneAndUpdate", reflect.TypeOf((*MockClient)(nil).FindOneAndUpdate), varargs...)
}

// Indexes mocks base method.
func (m *MockClient) Indexes(ctx context.Context, database, collection string) (mongo.IndexView, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Indexes", ctx, database, collection)
	ret0, _ := ret[0].(mongo.IndexView)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Indexes indicates an expected call of Indexes.
func (mr *MockClientMockRecorder) Indexes(ctx, database, collection interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Indexes", reflect.TypeOf((*MockClient)(nil).Indexes), ctx, database, collection)
}

// InsertMany mocks base method.
func (m *MockClient) InsertMany(ctx context.Context, database, coll string, documents []interface{}, opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, documents}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertMany", varargs...)
	ret0, _ := ret[0].(*mongo.InsertManyResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMany indicates an expected call of InsertMany.
func (mr *MockClientMockRecorder) InsertMany(ctx, database, coll, documents interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, documents}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMany", reflect.TypeOf((*MockClient)(nil).InsertMany), varargs...)
}

// InsertOne mocks base method.
func (m *MockClient) InsertOne(ctx context.Context, database, coll string, document interface{}, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, document}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOne", varargs...)
	ret0, _ := ret[0].(*mongo.InsertOneResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockClientMockRecorder) InsertOne(ctx, database, coll, document interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, document}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockClient)(nil).InsertOne), varargs...)
}

// ReplaceOne mocks base method.
func (m *MockClient) ReplaceOne(ctx context.Context, database, coll string, filter, replacement interface{}, opts ...*options.ReplaceOptions) (*mongo.UpdateResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter, replacement}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReplaceOne", varargs...)
	ret0, _ := ret[0].(*mongo.UpdateResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReplaceOne indicates an expected call of ReplaceOne.
func (mr *MockClientMockRecorder) ReplaceOne(ctx, database, coll, filter, replacement interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter, replacement}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReplaceOne", reflect.TypeOf((*MockClient)(nil).ReplaceOne), varargs...)
}

// RunCommand mocks base method.
func (m *MockClient) RunCommand(ctx context.Context, database string, runCommand interface{}, opts ...*options.RunCmdOptions) *mongo.SingleResult {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, runCommand}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunCommand", varargs...)
	ret0, _ := ret[0].(*mongo.SingleResult)
	return ret0
}

// RunCommand indicates an expected call of RunCommand.
func (mr *MockClientMockRecorder) RunCommand(ctx, database, runCommand interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, runCommand}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunCommand", reflect.TypeOf((*MockClient)(nil).RunCommand), varargs...)
}

// StartSession mocks base method.
func (m *MockClient) StartSession(ctx context.Context) (mongo.Session, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartSession", ctx)
	ret0, _ := ret[0].(mongo.Session)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartSession indicates an expected call of StartSession.
func (mr *MockClientMockRecorder) StartSession(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartSession", reflect.TypeOf((*MockClient)(nil).StartSession), ctx)
}

// Transaction mocks base method.
func (m *MockClient) Transaction(ctx context.Context, sf mongodb.TxFunc, tOpts []*options.TransactionOptions, opts ...*options.SessionOptions) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, sf, tOpts}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Transaction", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Transaction indicates an expected call of Transaction.
func (mr *MockClientMockRecorder) Transaction(ctx, sf, tOpts interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, sf, tOpts}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Transaction", reflect.TypeOf((*MockClient)(nil).Transaction), varargs...)
}

// UpdateMany mocks base method.
func (m *MockClient) UpdateMany(ctx context.Context, database, coll string, filter, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter, update}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateMany", varargs...)
	ret0, _ := ret[0].(*mongo.UpdateResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateMany indicates an expected call of UpdateMany.
func (mr *MockClientMockRecorder) UpdateMany(ctx, database, coll, filter, update interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter, update}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMany", reflect.TypeOf((*MockClient)(nil).UpdateMany), varargs...)
}

// UpdateOne mocks base method.
func (m *MockClient) UpdateOne(ctx context.Context, database, coll string, filter, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, filter, update}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateOne", varargs...)
	ret0, _ := ret[0].(*mongo.UpdateResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockClientMockRecorder) UpdateOne(ctx, database, coll, filter, update interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, filter, update}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockClient)(nil).UpdateOne), varargs...)
}

// Watch mocks base method.
func (m *MockClient) Watch(ctx context.Context, pipeline interface{}, opts ...*options.ChangeStreamOptions) (*mongo.ChangeStream, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, pipeline}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Watch", varargs...)
	ret0, _ := ret[0].(*mongo.ChangeStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Watch indicates an expected call of Watch.
func (mr *MockClientMockRecorder) Watch(ctx, pipeline interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, pipeline}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockClient)(nil).Watch), varargs...)
}

// WatchCollection mocks base method.
func (m *MockClient) WatchCollection(ctx context.Context, database, collection string, pipeline interface{}, opts ...*options.ChangeStreamOptions) (*mongo.ChangeStream, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, collection, pipeline}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WatchCollection", varargs...)
	ret0, _ := ret[0].(*mongo.ChangeStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WatchCollection indicates an expected call of WatchCollection.
func (mr *MockClientMockRecorder) WatchCollection(ctx, database, collection, pipeline interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, collection, pipeline}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchCollection", reflect.TypeOf((*MockClient)(nil).WatchCollection), varargs...)
}

// WatchDatabase mocks base method.
func (m *MockClient) WatchDatabase(ctx context.Context, database string, pipeline interface{}, opts ...*options.ChangeStreamOptions) (*mongo.ChangeStream, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, pipeline}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WatchDatabase", varargs...)
	ret0, _ := ret[0].(*mongo.ChangeStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WatchDatabase indicates an expected call of WatchDatabase.
func (mr *MockClientMockRecorder) WatchDatabase(ctx, database, pipeline interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, pipeline}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchDatabase", reflect.TypeOf((*MockClient)(nil).WatchDatabase), varargs...)
}

// MockIndexViewer is a mock of IndexViewer interface.
type MockIndexViewer struct {
	ctrl     *gomock.Controller
	recorder *MockIndexViewerMockRecorder
}

// MockIndexViewerMockRecorder is the mock recorder for MockIndexViewer.
type MockIndexViewerMockRecorder struct {
	mock *MockIndexViewer
}

// NewMockIndexViewer creates a new mock instance.
func NewMockIndexViewer(ctrl *gomock.Controller) *MockIndexViewer {
	mock := &MockIndexViewer{ctrl: ctrl}
	mock.recorder = &MockIndexViewerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexViewer) EXPECT() *MockIndexViewerMockRecorder {
	return m.recorder
}

// CreateMany mocks base method.
func (m *MockIndexViewer) CreateMany(ctx context.Context, database, coll string, models []mongo.IndexModel, opts ...*options.CreateIndexesOptions) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, models}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateMany", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateMany indicates an expected call of CreateMany.
func (mr *MockIndexViewerMockRecorder) CreateMany(ctx, database, coll, models interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, models}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMany", reflect.TypeOf((*MockIndexViewer)(nil).CreateMany), varargs...)
}

// CreateOne mocks base method.
func (m *MockIndexViewer) CreateOne(ctx context.Context, database, coll string, model mongo.IndexModel, opts ...*options.CreateIndexesOptions) (string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, model}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateOne", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateOne indicates an expected call of CreateOne.
func (mr *MockIndexViewerMockRecorder) CreateOne(ctx, database, coll, model interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, model}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOne", reflect.TypeOf((*MockIndexViewer)(nil).CreateOne), varargs...)
}

// DropAll mocks base method.
func (m *MockIndexViewer) DropAll(ctx context.Context, database, coll string, opts ...*options.DropIndexesOptions) (bson.Raw, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DropAll", varargs...)
	ret0, _ := ret[0].(bson.Raw)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DropAll indicates an expected call of DropAll.
func (mr *MockIndexViewerMockRecorder) DropAll(ctx, database, coll interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropAll", reflect.TypeOf((*MockIndexViewer)(nil).DropAll), varargs...)
}

// DropOne mocks base method.
func (m *MockIndexViewer) DropOne(ctx context.Context, database, coll, name string, opts ...*options.DropIndexesOptions) (bson.Raw, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, database, coll, name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DropOne", varargs...)
	ret0, _ := ret[0].(bson.Raw)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DropOne indicates an expected call of DropOne.
func (mr *MockIndexViewerMockRecorder) DropOne(ctx, database, coll, name interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, database, coll, name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropOne", reflect.TypeOf((*MockIndexViewer)(nil).DropOne), varargs...)
}
